"""MQTT packet handler for Meshtastic node tracking"""
import time
import json
import logging
from collections import deque
import configparser
import re
from . import config
import paho.mqtt.client as mqtt_client
from meshtastic import mesh_pb2, mqtt_pb2, portnums_pb2, telemetry_pb2
from google.protobuf.json_format import MessageToDict

logger = logging.getLogger(__name__)

# ===== GLOBALS =====
nodes_data = {}
special_node_packets = {}
special_node_last_packet = {}
special_node_channels = {}
special_history = {}
signal_history = {}
special_node_position_timestamps = {}
recent_messages = deque(maxlen=200)
special_node_gateway_connections = {}
preset_names = {}
node_topics = {}

# MQTT client and status
client = None
mqtt_status = 'connected_to_server'

# ===== MQTT CONFIGURATION FROM tracker.config =====
config_path = 'tracker.config'
tracker_cfg = configparser.ConfigParser()
tracker_cfg.read(config_path)

# MQTT connection parameters
MQTT_BROKER = tracker_cfg.get('mqtt', 'broker', fallback='localhost')
MQTT_PORT = tracker_cfg.getint('mqtt', 'port', fallback=1883)
MQTT_USERNAME = tracker_cfg.get('mqtt', 'username', fallback=None)
MQTT_PASSWORD = tracker_cfg.get('mqtt', 'password', fallback=None)
MQTT_KEEPALIVE = 60
MQTT_ROOT_TOPIC = tracker_cfg.get('mqtt', 'root_topic', fallback='msh/US/bayarea/2/e/')
MQTT_SUBSCRIBE_TOPIC = MQTT_ROOT_TOPIC + '#'

# ===== SPECIAL NODES CONFIGURATION =====
SPECIAL_NODE_IDS = []
SPECIAL_NODES = {}
SPECIAL_SYMBOL = tracker_cfg.get('special_nodes_settings', 'special_symbol', fallback='⭐')
MOVEMENT_THRESHOLD = tracker_cfg.getint('special_nodes', 'movement_threshold', fallback=80)

# Parse [special_nodes] section
for key, value in tracker_cfg.items('special_nodes'):
    # Only process numeric keys (node IDs)
    if not key.isdigit():
        continue
    try:
        node_id = int(key)
        label = None
        home_lat = None
        home_lon = None
        
        # Format: node_id = label,home_lat,home_lon
        value_clean = value.split('#')[0].strip() if value else ''
        parts = [p.strip() for p in value_clean.split(',')] if value_clean else []
        
        if len(parts) > 0:
            label = parts[0] if parts[0] else None
        if len(parts) > 1:
            home_lat = parts[1]
        if len(parts) > 2:
            home_lon = parts[2]
        
        SPECIAL_NODE_IDS.append(node_id)
        SPECIAL_NODES[node_id] = {
            'label': label,
            'home_lat': home_lat,
            'home_lon': home_lon,
            'symbol': SPECIAL_SYMBOL,
            'movement_threshold': MOVEMENT_THRESHOLD
        }
    except (ValueError, IndexError) as e:
        logger.warning(f"Error parsing special_nodes entry '{key}': {e}")

# ===== HELPER FUNCTIONS =====

def _degmin_to_decimal(coord):
    """Convert degrees-minutes format to decimal degrees."""
    if not coord:
        return None
    m = re.match(r"([NSWE])([0-9]+)[°\s]+([0-9.]+)'", str(coord))
    if not m:
        try:
            return float(coord)
        except Exception:
            return None
    hemi, deg, min_ = m.groups()
    deg = float(deg)
    min_ = float(min_)
    val = deg + min_ / 60.0
    if hemi in ['S', 'W']:
        val = -val
    return val

def extract_battery_voltage(payload):
    """Extract battery and voltage info from any packet payload."""
    voltage = None
    battery = None
    
    # Try common voltage keys
    for key in ["voltage", "battery_voltage", "batV", "bat", "voltageV", "vbat", "VBAT", "batt", "battV"]:
        if key in payload:
            voltage = payload[key]
            break
    
    # Try to coerce voltage to float
    try:
        if voltage is not None:
            voltage = float(voltage)
    except Exception:
        voltage = None
    
    # Estimate battery % from voltage
    if voltage is not None:
        if voltage >= 4.2:
            battery = 100
        elif voltage <= 3.0:
            battery = 0
        else:
            battery = int(((voltage - 3.0) / 1.2) * 100)
    
    # Try common battery % keys
    for key in ["battery", "batt", "bat", "battery_percent", "batt_percent"]:
        if key in payload:
            try:
                battery = int(payload[key])
            except Exception:
                pass
            break
    
    return voltage, battery

def add_recent(json_data):
    """Add message to recent message buffer."""
    global recent_messages
    try:
        recent_messages.appendleft({"ts": time.time(), "msg": json_data})
    except Exception:
        recent_messages.appendleft({"ts": time.time(), "msg": str(json_data)})

def _ensure_history_struct(node_id):
    """Ensure history deque exists for node."""
    if node_id not in special_history:
        special_history[node_id] = deque(maxlen=100)

def _track_special_node_packet(node_id, packet_type, json_data):
    """Track packet for special node."""
    add_recent(json_data)
    pkts = special_node_packets.setdefault(node_id, [])
    pkts.insert(0, json_data)
    pkts[:] = pkts[:100]
    _ensure_history_struct(node_id)
    hist = special_history.setdefault(node_id, deque(maxlen=100))
    if 'lat' in json_data and 'lon' in json_data:
        hist.append({'ts': time.time(), 'lat': json_data['lat'], 'lon': json_data['lon']})

def _record_signal_history(node_id, rssi=None, snr=None):
    """Record signal quality history for node."""
    hist = signal_history.setdefault(node_id, deque(maxlen=100))
    hist.append({'ts': time.time(), 'rssi': rssi, 'snr': snr})

def _is_special_node(node_id):
    """Check if node is in special nodes list."""
    return node_id in SPECIAL_NODE_IDS

# ===== MQTT CALLBACKS =====

def on_connect(client, userdata, flags, rc):
    """Called when MQTT client connects to broker."""
    if rc == 0:
        logger.info("[MQTT] Connected successfully to broker")
    else:
        logger.warning(f"[MQTT] Connection failed with code {rc}")

def on_disconnect(client, userdata, rc):
    """Called when MQTT client disconnects from broker."""
    logger.warning(f"[MQTT] Disconnected from broker (code {rc})")

def _calculate_distance_m(lat1, lon1, lat2, lon2):
    """Calculate distance in meters between two lat/lon points (Haversine formula)."""
    if None in [lat1, lon1, lat2, lon2]:
        return None
    from math import radians, sin, cos, sqrt, atan2
    R = 6371000  # Earth radius in meters
    phi1 = radians(lat1)
    phi2 = radians(lat2)
    delta_phi = radians(lat2 - lat1)
    delta_lambda = radians(lon2 - lon1)
    a = sin(delta_phi/2)**2 + cos(phi1) * cos(phi2) * sin(delta_lambda/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    return R * c

def on_message(client, userdata, msg):
    """Called when MQTT message is received."""
    global mqtt_status
    try:
        logger.debug(f"[MQTT] Message received on topic: {msg.topic}")
        
        # Parse Meshtastic protobuf packet
        mesh_pkt = mesh_pb2.MeshPacket()
        mesh_pkt.ParseFromString(msg.payload)
        
        node_id = mesh_pkt.id if hasattr(mesh_pkt, 'id') else None
        if not node_id:
            return
        
        now = time.time()
        node = nodes_data.setdefault(node_id, {})
        node['id'] = node_id
        node['last_seen'] = now
        node['is_special'] = node_id in SPECIAL_NODE_IDS
        
        # Extract from_id to check if sender is a gateway/router
        if hasattr(mesh_pkt, 'from_id') and mesh_pkt.from_id != 0:
            # Check if from_id is a router (can be detected from want_ack, is_router flags, or from nodeinfo)
            # For now, we mark nodes that route packets as potential gateways
            pass
        
        # ===== Position Data =====
        lat = None
        lon = None
        alt = None
        if hasattr(mesh_pkt, 'position') and mesh_pkt.HasField('position'):
            pos = mesh_pkt.position
            lat = pos.latitude_i / 1e7 if pos.HasField('latitude_i') else None
            lon = pos.longitude_i / 1e7 if pos.HasField('longitude_i') else None
            alt = pos.altitude if pos.HasField('altitude') else None
            
            if lat is not None:
                node['lat'] = lat
            if lon is not None:
                node['lon'] = lon
            if alt is not None:
                node['alt'] = alt
            
            # Track position update time for special nodes
            if node['is_special']:
                node['last_position_update'] = now
        
        # ===== Telemetry Data =====
        battery = None
        voltage = None
        if hasattr(mesh_pkt, 'telemetry') and mesh_pkt.HasField('telemetry'):
            tel = mesh_pkt.telemetry
            battery = tel.battery_level if tel.HasField('battery_level') else None
            voltage = tel.voltage if tel.HasField('voltage') else None
            
            if battery is not None:
                node['battery'] = battery
            if voltage is not None:
                node['improved_voltage'] = voltage / 1000.0  # Convert millivolts to volts
        
        # ===== Node Info (long_name, hw_model, role, etc) =====
        # NodeInfo is typically sent in a separate packet (not in MeshPacket directly)
        # For now, extract what's available in the position/telemetry payloads
        if hasattr(mesh_pkt, 'decoded') and mesh_pkt.HasField('decoded'):
            decoded = mesh_pkt.decoded
            # Extract payload if present
            if hasattr(decoded, 'payload') and decoded.payload:
                try:
                    payload_dict = MessageToDict(decoded)
                    # Look for user info in payload
                    if 'user' in payload_dict:
                        user_info = payload_dict['user']
                        if 'longName' in user_info:
                            node['long_name'] = user_info['longName']
                        if 'shortName' in user_info:
                            node['short'] = user_info['shortName']
                        if 'hwModel' in user_info:
                            node['hw_model'] = user_info['hwModel']
                        if 'role' in user_info:
                            node['role'] = user_info['role']
                except Exception as e:
                    logger.debug(f"Failed to extract node info from payload: {e}")
        
        # ===== Distance Calculation for Special Nodes =====
        if node['is_special'] and lat is not None and lon is not None:
            special_info = SPECIAL_NODES.get(node_id, {})
            origin_lat = _degmin_to_decimal(special_info.get('home_lat')) if special_info.get('home_lat') else None
            origin_lon = _degmin_to_decimal(special_info.get('home_lon')) if special_info.get('home_lon') else None
            
            if origin_lat is not None and origin_lon is not None:
                distance_m = _calculate_distance_m(origin_lat, origin_lon, lat, lon)
                if distance_m is not None:
                    node['distance_from_origin_m'] = distance_m
                    # Check if moved beyond threshold
                    threshold = special_info.get('movement_threshold', MOVEMENT_THRESHOLD)
                    node['moved_far'] = distance_m > threshold
        
        # ===== Battery Status =====
        if battery is not None or voltage is not None:
            # Determine low battery status
            battery_low = False
            if battery is not None and battery < getattr(config, 'LOW_BATTERY_THRESHOLD', 25):
                battery_low = True
            if voltage is not None and voltage < 3300:  # 3.3V threshold
                battery_low = True
            node['battery_low'] = battery_low
        
        # ===== Track Special Node Packets =====
        if node['is_special']:
            last_pkt = special_node_last_packet.get(node_id, {})
            pkt_type = type(mesh_pkt).__name__
            pkt_time = now
            
            # Skip duplicate packets within 2 seconds
            if pkt_type in last_pkt and abs(pkt_time - last_pkt[pkt_type]) < 2:
                return
            
            last_pkt[pkt_type] = pkt_time
            special_node_last_packet[node_id] = last_pkt
            
            # Track packet and history
            _track_special_node_packet(node_id, pkt_type, MessageToDict(mesh_pkt))
        
        mqtt_status = 'receiving_packets'
    except Exception as e:
        logger.error(f"[MQTT] Error processing message: {e}", exc_info=True)

# ===== MQTT CONNECTION =====

def get_mqtt_status():
    """Get current MQTT status."""
    global mqtt_status
    return mqtt_status

def is_connected():
    """Check if MQTT client is connected."""
    global client
    if client is not None:
        try:
            return client.is_connected()
        except Exception:
            return False
    return False

def connect_mqtt():
    """Connect to MQTT broker and start message loop."""
    global client
    try:
        logger.info(f"[MQTT] Creating client and connecting to {MQTT_BROKER}:{MQTT_PORT}")
        client = mqtt_client.Client()
        
        if MQTT_USERNAME and MQTT_PASSWORD:
            logger.info(f"[MQTT] Setting credentials: {MQTT_USERNAME}/****")
            client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
        
        # Set callbacks
        client.on_connect = on_connect
        client.on_disconnect = on_disconnect
        client.on_message = on_message
        
        # Connect and subscribe
        client.connect(MQTT_BROKER, MQTT_PORT, MQTT_KEEPALIVE)
        client.loop_start()
        client.subscribe(MQTT_SUBSCRIBE_TOPIC)
        
        logger.info(f"[MQTT] Connected and subscribed to {MQTT_SUBSCRIBE_TOPIC}")
        return True
    except Exception as e:
        logger.error(f"[MQTT] Connection failed: {e}", exc_info=True)
        return False

# ===== API FUNCTIONS =====

def get_recent(limit=100):
    """Get recent messages."""
    return list(recent_messages)[:limit]

def get_special_history(node_id, hours):
    """Get position history for special node within time window."""
    history = special_history.get(node_id, [])
    cutoff = time.time() - hours * 3600
    return [pt for pt in history if pt.get('ts', 0) >= cutoff]

def get_special_node_packets(node_id=None, limit=50):
    """Get packets for special node(s)."""
    if node_id is not None:
        packets = special_node_packets.get(node_id, [])
        return {node_id: packets[:limit]}
    else:
        return {nid: pkts[:limit] for nid, pkts in special_node_packets.items()}

def get_signal_history(node_id):
    """Get signal history (RSSI, SNR) for node."""
    return list(signal_history.get(node_id, []))

def get_nodes():
    """Get all nodes with current status, including special node position data."""
    out = []
    for node_id, node in nodes_data.items():
        node_dict = dict(node)
        node_dict['id'] = node_id
        node_dict['is_special'] = node.get('is_special', False)
        node_dict['is_gateway'] = node.get('is_gateway', False)
        
        now = time.time()
        
        # ===== Special Node Processing =====
        if node_dict['is_special']:
            special_info = SPECIAL_NODES.get(node_id, {})
            
            # Origin position (for green rings on map)
            origin_lat = _degmin_to_decimal(special_info.get('home_lat')) if special_info.get('home_lat') else None
            origin_lon = _degmin_to_decimal(special_info.get('home_lon')) if special_info.get('home_lon') else None
            node_dict['origin_lat'] = origin_lat
            node_dict['origin_lon'] = origin_lon
            
            # Movement threshold
            node_dict['movement_threshold'] = special_info.get('movement_threshold', MOVEMENT_THRESHOLD)
            
            # If no packet received yet, use home position from config
            if node.get('lat') is None and origin_lat is not None:
                node_dict['lat'] = origin_lat
            if node.get('lon') is None and origin_lon is not None:
                node_dict['lon'] = origin_lon
            
            # Ensure distance_from_origin_m is set (even if 0)
            if 'distance_from_origin_m' not in node_dict and origin_lat is not None and origin_lon is not None:
                if node.get('lat') is not None and node.get('lon') is not None:
                    distance_m = _calculate_distance_m(origin_lat, origin_lon, node['lat'], node['lon'])
                    if distance_m is not None:
                        node_dict['distance_from_origin_m'] = distance_m
                        node_dict['moved_far'] = distance_m > special_info.get('movement_threshold', MOVEMENT_THRESHOLD)
        
        # ===== Name Fields =====
        node_dict['long_name'] = node.get('long_name', node.get('name', 'Unknown'))
        node_dict['short'] = node.get('short', '?')
        node_dict['name'] = node_dict['long_name']  # Alias for compatibility
        
        # ===== Metadata Fields =====
        node_dict['hw_model'] = node.get('hw_model', 'Unknown')
        node_dict['role'] = node.get('role', 'Unknown')
        node_dict['channel_name'] = node.get('channel_name')
        node_dict['modem_preset'] = node.get('modem_preset')
        
        # ===== Battery/Voltage Fields =====
        node_dict['battery'] = node.get('battery')
        node_dict['voltage'] = node.get('voltage')
        node_dict['improved_voltage'] = node.get('improved_voltage')
        node_dict['battery_low'] = node.get('battery_low', False)
        
        # ===== Time Since Last Seen =====
        last_seen = node.get('last_seen', 0)
        node_dict['time_since_seen'] = int(now - last_seen) if last_seen > 0 else 999999
        
        # ===== Gateway Connections =====
        node_dict['gateway_connections'] = node.get('gateway_connections', [])
        node_dict['best_gateway'] = node.get('best_gateway')
        
        # ===== Status Color =====
        age = node_dict['time_since_seen']
        node_dict['status'] = 'gray'  # Default for nodes with no position
        
        if node_dict['is_special']:
            # Special node status logic:
            # 'gray' = waiting for GPS fix (no position yet)
            # 'green' = recent position
            # 'yellow' = stale position
            # 'red' = very stale position
            if node.get('lat') is None or node.get('lon') is None:
                node_dict['status'] = 'gray'
                node_dict['status_color'] = 'gray'
            elif age < getattr(config, 'STATUS_BLUE_THRESHOLD', 3600):
                node_dict['status'] = 'online'
                node_dict['status_color'] = 'green'
            elif age < getattr(config, 'STATUS_ORANGE_THRESHOLD', 43200):
                node_dict['status'] = 'orange'
                node_dict['status_color'] = 'yellow'
            else:
                node_dict['status'] = 'red'
                node_dict['status_color'] = 'red'
        else:
            # Regular node status logic:
            # 'online' = recently seen
            # 'blue' = seen but older
            # 'orange' = very old
            # 'red' = extremely old
            if age < getattr(config, 'STATUS_BLUE_THRESHOLD', 3600):
                node_dict['status'] = 'online'
                node_dict['status_color'] = 'green'
            elif age < getattr(config, 'STATUS_ORANGE_THRESHOLD', 43200):
                node_dict['status'] = 'blue'
                node_dict['status_color'] = 'blue'
            elif age < 86400 * 7:  # 7 days
                node_dict['status'] = 'orange'
                node_dict['status_color'] = 'orange'
            else:
                node_dict['status'] = 'red'
                node_dict['status_color'] = 'red'
        
        out.append(node_dict)
    
    return out

# ===== INITIALIZATION =====

# Initialize special nodes in nodes_data with home positions
for node_id, info in SPECIAL_NODES.items():
    node = nodes_data.setdefault(node_id, {})
    node['id'] = node_id
    node['is_special'] = True
    node['is_gateway'] = False
    node['long_name'] = info['label'] or str(node_id)
    node['name'] = node['long_name']
    node['short'] = '?'
    node['lat'] = _degmin_to_decimal(info['home_lat']) if info['home_lat'] else None
    node['lon'] = _degmin_to_decimal(info['home_lon']) if info['home_lon'] else None
    node['symbol'] = info['symbol']
    node['movement_threshold'] = MOVEMENT_THRESHOLD
    node['last_seen'] = time.time()
    node['hw_model'] = 'Unknown'
    node['role'] = 'Unknown'
    node['battery'] = None
    node['voltage'] = None
    node['improved_voltage'] = None
    node['battery_low'] = False
    node['time_since_seen'] = 0
    node['gateway_connections'] = []
    node['best_gateway'] = None
    node['status'] = 'gray'  # Waiting for GPS
    node['status_color'] = 'gray'
    node['moved_far'] = False
    node['distance_from_origin_m'] = None

logger.info(f"[MQTT] Initialized {len(SPECIAL_NODE_IDS)} special nodes: {SPECIAL_NODE_IDS}")

